# Lab 3: Data cleaning {.unnumbered}

You should begin this session with variables from the ANES 2016 dataset in mind for your analysis. In class we will introduce the R language and RStudio environment, and perform necessary data cleaning and manipulation in preparation for analysis.


## Goals

- Get your R environment set up
- Read the data you need into R
- Select required variables
- Filter the data based on completeness (and any other criteria)
- Compute any required variables (scale means, number of items missing, etc)


# Working with data in R

## Getting R ready

In addition to containing a Big 5 personality scale, the ANES 2016 dataset is convenient for our purposes because someone went to the trouble of creating an R package which makes working with the ANES data relatively straightforward (not that you won't still run into issues!): `anesr` ([github.com/jamesmartherus/anesr](https://github.com/jamesmartherus/anesr)).

To start exploring the data in R, you first need to set up your environment. This means installing the `anesr` package from github. Since the package is hosted on GitHub (as opposed to the official R repository of packages), the easiest way to install it is by first installing the `devtools` package, which has a function for installing other packages from GitHub.

```{r}
#| eval: false

install.packages("devtools")

devtools::install_github("jamesmartherus/anesr")

```


We will also use some other packages for data wrangling and analysis. Developers have created a collection of packages for R called the `tidyverse` to make coding these common tasks easier. The `tidyverse` can be installed like so:

```{r}
#| eval: false

install.packages("tidyverse")

```

If you execute those lines of code the packages will be installed on your system. That step only needs to be done once, but you need to 'activate' the packages using `library()` to make their functions and data available each time to start a new R session.

```{r}
#| warning: false
#| message: false

library(anesr)
library(tidyverse)

```


## Getting data into R

```{r}

data(timeseries_2016)

```

When you run that line of code you won't see any output, but you should see the name `timeseries_2016` appear in your Environment pane. That is now an object in R called a data.frame. You can think of it as a spreadsheet like you're familiar with from Excel or Google Sheets; a set of columns, one for each variable in the dataset, and a row for each participant's answers.

Here's what a few of the columns and rows look like:

```{r}
head(timeseries_2016)
```

You can click on the name in the Environment pane to see the data like a spreadsheet in a new tab.



### Select your variables

As you can see, the data.frame contains a *lot* of variables; there are 1,842 columns of data. You'll only need a few of those. So the first step is selecting just the variables you need to work with.

There are a lot of ways to do this. The simplest would be to make a note of the variable IDs from the codebook and use them within `dplyr`'s `select()` function. This allows us to simply type in variable names separated by commas. You can also give the columns new names when selecting,

For this example I'll look at the correlation between extraversion and the 'feeling thermometer' for the Democratic Party. Extraversion has two TIPI items; their IDs (from the codebook) are `V162333` and `V162338`. The ID for the Democratic Party feeling thermometer is `V161095`. 

```{r}

my_data <- timeseries_2016 |> 
  select(extraversion1 = "V162333", 
         extraversion2 = "V162338", ,
         feeling_thermometer = "V161095")

```

Let's see what this new data.frame looks like:

```{r}
head(my_data)
```

It all looks good so far. But if you inspect the data more extensively (click the name in your Environment and scroll down a bit) you'll notice that there are some negative numbers in the data. That's from survey codes which record missing data. If you try to calculate an average score with those included it'll mess up the sums, so we need to do some data cleaning to handle things like that.


### Cleaning the data

There are a lot of different ways we could handle this. One way is to `filter()` the data, retaining only rows which meet certain conditions.

```{r}

my_data_complete <- my_data |>
  filter(if_all(contains("extraversion"), ~ . %in% 1:7))  |> 
  filter(feeling_thermometer >= 0)

```

Notice how many rows have been removed:

```{r}

nrow(my_data)
nrow(my_data_complete)

```

Another way would be to `mutate()` the data; that is, change certain values based on some condition.

```{r}

# my_data_complete <- my_data |>
#     mutate(across(contains("extraversion"), ~case_when(
#         . < 1 ~ NA,
#         TRUE ~ .
#     ))) |> 
#     mutate(feeling_thermometer = case_when(feeling_thermometer < 0 ~ NA, TRUE ~ feeling_thermometer))

```



### Computing scale averages

Now that the data is subsetted and the missing/invalid responses are taken care of, the last thing to do is compute any new values required for analysis. As an example, if you have a scale which has multiple questions asking about a particular construct, it is often necessary to compute an average score for each participant.

The TIPI has 10 questions in total, two for each of the Big 5 personality traits. So it may be desirable to compute a mean trait score by averaging its two respective items.

Notice, however, that for each of the 5 traits, one question is positively worded and one is negatively worded. For extraversion, item `V162333` is "extraverted, enthusiastic", while item `V162338` is "reserved, quiet". The second one needs to be reverse-coded, so that higher scores on both items indicate greater extraversion. Since answers can range from 1 to 7, an easy way to recode the scores is to subtract the participant's response from 8; 1 becomes 7, 2 becomes 6, etc.

```{r}

my_data_complete <- my_data_complete |>
    mutate(extraversion2 = 8 - extraversion2)

```

Now we can go ahead and compute the average, using `mutate()` to create a new column containing the `rowMeans()` (i.e. an average for each row) for the specified columns.

```{r}

my_data_complete <- my_data_complete |>
    mutate(extraversion_mean = rowMeans(across(contains("extraversion"))))

```
