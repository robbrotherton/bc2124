

::: {#container}
:::

<input id="target-r" type="range" min=-1 max = 1 step = 0.01>


```{ojs}
//| echo: false
jStat = require("https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js")

chart = {

const width = 500
const height = 400

const xScale = d3.scaleLinear()
  .domain([-0.1, 1.1])
  .range([0, width])
let yScale = d3.scaleLinear()
  .domain([0, 1])
  .range([height, 0])


  
const svg = d3.select("#container").append("svg")
  .attr("width", width)
  .attr("height", height)
  
const meanLines = svg.append("g")
const axisLines = svg.append("g")

axisLines.append("line")
  .attr("class", "axis-line")
  .attr("x1", 1).attr("x2", width)
  .attr("y1", height - 1).attr("y2", height - 1)
  .style("stroke", "black")
axisLines.append("line")
  .attr("class", "axis-line")
  .attr("x1", 1).attr("x2", 1)
  .attr("y1", height - 1).attr("y2", 1)
  .style("stroke", "black")

const rInput = d3.select("#target-r");

rInput.on("input", () => updateChart(rInput.property("value")))

let data = makeInitialData(100);
  


function makeInitialData(n) {
    let arr = [];
    for (var i = 0; i < n; i++) {
        var A = Math.random();
        var B = Math.random();
        arr.push({xVal: A, y0: B});
    }
    return arr;
}

function computeYValue(x, y, r) {
 return x * r + y * Math.pow(1 - Math.pow(r, 2), 0.5);
}


function updateChart(targetR) {
  
  let newData = [];
  
  for (let i = 0; i < data.length; i++) {
    newData.push({
      xVal: data[i].xVal,
      yVal: computeYValue(data[i].xVal, data[i].y0, targetR)
    });
  }
  
  let yLimits = [
    Math.min(...newData.map(obj => obj.yVal)) - 0.1,
    Math.max(...newData.map(obj => obj.yVal)) + 0.1
  ];

  yScale.domain(yLimits);
  
  svg.selectAll("circle").remove()
  svg.selectAll("circle").data(newData).enter().append("circle")
    .attr("cx", d => xScale(d.xVal))
    .attr("r", 2)
    .attr("cy", d => yScale(d.yVal));
    
  let xArr = newData.map(obj => obj.xVal);
  let yArr = newData.map(obj => obj.yVal);
  
  let meanX = jStat.mean(xArr);
  let meanY = jStat.mean(yArr);
  
  meanLines.selectAll("line").remove()
  meanLines.append("line")
    .attr("x1", xScale(0)).attr("x2", xScale(1))
    .attr("y1", yScale(meanY)).attr("y2", yScale(meanY))
    .attr("stroke", "black")
  meanLines.append("line")
    .attr("x1", xScale(meanX)).attr("x2", xScale(meanX))
    .attr("y1", yScale(yLimits[0] + 0.1)).attr("y2", yScale(yLimits[1] - 0.1))
    .attr("stroke", "black")
    
  drawDeviationPolygons(meanX, meanY, yLimits);
  
  let actualR = jStat.corrcoeff(xArr, yArr);
  console.log("target r: " + targetR);
  console.log("actual r: " + actualR);
  
}

function drawDeviationPolygons(meanX, meanY, yLimits) {
  
  meanLines.selectAll("polygon").remove()
  
  // positive x & y
  meanLines.append("polygon")
    .attr("points", [[xScale(meanX), yScale(yLimits[1] - 0.1)],
                     [xScale(1), yScale(yLimits[1] - 0.1)],
                     [xScale(1), yScale(meanY)],
                     [xScale(meanX), yScale(meanY)]])
    .attr("fill", "green")
    .attr("opacity", 0.2)
  // negative x & y
  meanLines.append("polygon")
    .attr("points", [[xScale(0), yScale(meanY)],
                     [xScale(meanX), yScale(meanY)],
                     [xScale(meanX), yScale(yLimits[0] + 0.1)],
                     [xScale(0), yScale(yLimits[0] + 0.1)]])
    .attr("fill", "green")
    .attr("opacity", 0.2)
    
  // negative x, positive y
  meanLines.append("polygon")
    .attr("points", [[xScale(meanX), yScale(yLimits[1] - 0.1)],
                     [xScale(meanX), yScale(meanY)],
                     [xScale(0), yScale(meanY)],
                     [xScale(0), yScale(yLimits[1] - 0.1)]])
    .attr("fill", "red")
    .attr("opacity", 0.2)
  // positive x, negative y
  meanLines.append("polygon")
    .attr("points", [[xScale(meanX), yScale(meanY)],
                     [xScale(1), yScale(meanY)],
                     [xScale(1), yScale(yLimits[0] + 0.1)],
                     [xScale(meanX), yScale(yLimits[0] + 0.1)]])
    .attr("fill", "red")
    .attr("opacity", 0.2)
}

updateChart(rInput.property("value"));


}


```
